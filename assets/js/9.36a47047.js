(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{172:function(t,e,a){t.exports=a.p+"assets/img/ast1.8aee8887.jpg"},173:function(t,e,a){t.exports=a.p+"assets/img/ast2.eb2e535c.png"},208:function(t,e,a){"use strict";a.r(e);var s=[function(){var t=this.$createElement,e=this._self._c||t;return e("h1",{attrs:{id:"ast-基础"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ast-基础","aria-hidden":"true"}},[this._v("#")]),this._v(" AST 基础")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"tip custom-block"},[e("p",{staticClass:"custom-block-title"},[this._v("TIP")]),this._v(" "),e("p",[this._v("抽象语法树（Abstract Syntax Tree）")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简介","aria-hidden":"true"}},[this._v("#")]),this._v(" 简介")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"机器语言"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#机器语言","aria-hidden":"true"}},[this._v("#")]),this._v(" 机器语言")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("在讲AST之前先了解下机器语言的类型：\n从某一角度分类为："),e("code",[this._v("编译型")]),this._v(" 和 "),e("code",[this._v("解释型")])])},function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("table",{attrs:{cellspacing:"0"}},[a("col",{attrs:{width:""}}),t._v(" "),a("col",{attrs:{width:"50%"}}),t._v(" "),a("col",{attrs:{width:"50%"}}),t._v(" "),a("thead",[a("tr",[a("th"),t._v(" "),a("th",[t._v("解释性语言")]),t._v(" "),a("th",[t._v("编译型语言")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("概念")]),t._v(" "),a("td",{attrs:{colspan:"2"}},[t._v("计算机不能直接的理解高级语言，只能直接理解机器语言，所以必须要把高级语言翻译成机器语言，计算机才能执行高级语言的编写的程序。翻译的方式有两种，一个是编译，一个是解释。两种方式只是翻译的时间不同。 ")])]),t._v(" "),a("tr",[a("td",[t._v("特征")]),t._v(" "),a("td",[t._v("解释性语言的程序不需编译，在运行程序时才翻译。例如javaScript每一个语句都是执行的时候才能翻译。这样解释性语言每执行一次要翻译一次，效率表较低。")]),t._v(" "),a("td",[t._v("编译型就是编译的时候直接编译成机器可以执行的（.exe .dll .ocx）,编译和执行是分开的，但是不能跨平台。例如Delphi,C++,ASM,C是直接变异成exe文件并且自带条件编译功能。比如exe文件，以后要运行的话就不用重新编译了，直接使用编译的结果就行了（exe文件），因为翻译只做了一次，运行的时不要翻译，所以编译型语言的程序执行效率高。")])]),t._v(" "),a("tr",[a("td",{attrs:{rowspan:"3"}},[t._v("区别")]),t._v(" "),a("td",[t._v("对于解释性语言而言，程序运行时的控制权在解释器(jre,.net)而不再用于程序。")]),t._v(" "),a("td",[t._v("对于编译器而言，运行时的控制权在用户程序。")])]),t._v(" "),a("tr",[a("td",[t._v("一些网页脚本，服务器脚本以及辅助开发接口这样的对速度要求不高，对不同系统的兼容性有一定要求的程序则通常使用解释性语言，如Java、JavaScript、VBScript、Perl、Python、Ruby、Matlab等等。(jre,.net)而不再用于程序。")]),t._v(" "),a("td",[t._v("编译语言由于程序执行速度快，同等条件下对系统的要求比较低，因此像开发操作系统、大型应用程序、数据库系统等时都采用它，像C/C++,Pascal/Object Pascal(Delphi)等都是编译型语言。")])]),t._v(" "),a("tr",[a("td",[t._v("解释型语言，例如Java语言，Java程序首先通过编译器编译成class文件，如果在Windows平台上运行，则通过Windows平台上的Java虚拟机（VM）进行解释。如果运行在Linux平台上，则通过Linux平台上的Java虚拟机进行解释执行。所以说能跨平台，前提是平台上必须要有相匹配的Java虚拟机。如果没有Java虚拟机，则不能进行跨平台。")]),t._v(" "),a("td",[t._v("编译型语言，例如C语言,用C语言开发程序后，需要通过编译器把程序编译成机器语言（即计算机可以识别的二进制文件，因为不同的操作系统识别的二进制文件是不同的），所以C语言程序进行移植后，需要重新编译（如Windows编译成ext文件，Linux编译成erp文件）")])]),t._v(" "),a("tr",[a("td",{attrs:{rowspan:"2"}},[t._v("总结")]),t._v(" "),a("td",[t._v("优点：可移植性好，只要有解释环境，可以在不同的操作系统上运行。比如在解释执行时可以动态改变变量的类型、对程序进行修改以及在程序中插入良好的调试诊断信息等，而将解释器移植到不同的系统上，则程序不用改动就可以在移植了解释器系统上运行。")]),t._v(" "),a("td",[t._v("优点：运行速度快，代码效率高，编译后程序不可以修改，保密性好。")])]),t._v(" "),a("tr",[a("td",[t._v("缺点：运行需要解释环境，运行起来比编译的要慢，占用的资源也要多一些，代码效率低，代码修改后就可以运行，不需要编译过程。因为不仅要给用户程序分配空间，解释器本身也占用了宝贵的系统资源。其封装底层代码，程序严重依赖平台。不能同C++，VB那样直接操作底层。")]),t._v(" "),a("td",[t._v("缺点：代码需要经过编译方可运行，可移植性差，只能在兼容的操作系统上运行。")])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:a(172),alt:""}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"机器语言的执行过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#机器语言的执行过程","aria-hidden":"true"}},[this._v("#")]),this._v(" 机器语言的执行过程")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("对于常见编译型语言来说，编译步骤分为："),e("code",[this._v("词法分析 -> 语法分析 -> 语义检查 -> 代码优化和字节码生成")]),this._v("。")]),this._v(" "),e("li",[this._v("对于解释型语言（例如 JavaScript）来说，通过"),e("code",[this._v("词法分析 -> 语法分析 -> 语法树")]),this._v("，就可以开始解释执行了。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:a(173),alt:""}})])}],r=a(0),_=Object(r.a)({},function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("div",{staticClass:"content"},[t._m(0),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),a("ul",[a("li",[t._v("官方介绍 "),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/Abstract_syntax_tree",target:"_blank",rel:"noopener noreferrer"}},[t._v("抽象语法树"),a("OutboundLink")],1)]),t._v(" "),a("li",[t._v("AST是指抽象语法树（abstract syntax tree），或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式。")])]),t._v(" "),t._m(3),t._v(" "),t._m(4),t._v(" "),t._m(5),t._v(" "),t._m(6),t._v(" "),t._m(7),t._v(" "),t._m(8),t._v(" "),a("p",[t._v("下图是一个语法树的图示：")]),t._v(" "),t._m(9)])},s,!1,null,null,null);_.options.__file="intro.md";e.default=_.exports}}]);